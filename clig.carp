(load "src/flag.carp")
(load "src/error.carp")

(deftype CligProgram [name   String
                      flags  (Map String CligFlag)
                      errors (Array CligErr)
                      args   (Array String)
                      usage  String])
(defmodule Clig
  (doc new "Returns a new Clig program.")
  (defn new [name usage-string]
    (let [options (Map.create)
          errs    []
          args    []]
      (CligProgram.init name options errs args usage-string)))

  (doc usage "Returns the usage string for a program.")
  (defn usage [program]
    (let [flags (Map.vals (CligProgram.flags program))
          flag-helps (copy-map &flag-usage &flags)
          cli-help (String.join ": " &[@(CligProgram.name program) @(CliProgram.usage program)])
          full-help (Array.concat &[[cli-help] flag-helps])]
      (String.join "\n\t" &full-help)))

  (doc add-flag "Adds a flag to a Clig program.")
  (defn add-flag [program the-flag]
    (let [existing (CligProgram.flags program)
          name     (CligFlag.name the-flag)
          errs     (CligProgram.errors program)]
      (match (get-maybe existing name)
        (Maybe.Just _)  (push-back! errs (Clig.Err.flag-exists @name))
        (Maybe.Nothing) (Map.put! existing name the-flag))))

  (doc get-flag "Retrieves a program flag.")
  (defn get-flag [program flag-name]
    (let [flags (CligProgram.flags program)]
      (get-maybe flags flag-name)))

  (doc get "Retrieves the value of a program flag. Returns an empty string when
  the flag does not exist.")
  (defn get [program flag-name]
    (let [flags (CligProgram.flags program)
          default (CligFlag @"" (Maybe.Nothing) (CligType.String) @"" @"" @"")
          flag  (get-with-default flags flag-name &default)]
      @(CliFlag.value &flag)))

  ;; TODO: Match on short names
  (defn parse-flag [program flag-name arg]
    (let [flags (CligProgram.flags program)
          errs  (CligProgram.errors program)
          name  (Pattern.substitute #"^\-\-?" flag-name "" 1)]
      (match (get-maybe flags &name)
        (Maybe.Nothing)
          (do (push-back! errs (Clig.Err.unknown-flag @flag-name))
              (Result.Error @(unsafe-first errs)))
        (Maybe.Just f)
          (match-ref (CligFlag.t &f)
            (CligType.Bool)
              (do (Map.put! flags &name &(CligFlag.set-value f @"true"))
                  (Result.Success 0))
            _ (match arg
                (Maybe.Nothing)
                  (do (push-back! errs (Clig.Err.missing-argument @flag-name))
                      (Result.Error @(unsafe-first errs)))
                (Maybe.Just a)
                  (do (Map.put! flags &name &(CligFlag.set-value f a))
                      (Result.Success 1)))))))

  (doc parse "Parses program flags.")
  (defn parse [program fail]
    (let-do [errs (CligProgram.errors program)
             args &System.args
             res  (Result.Success ())
             cli-args (CligProgram.args program)]
      (if (not (empty? errs))
          (Result.Error @(unsafe-first errs))
          (do (for [i 0 (StaticArray.length args)]
                (let [arg (unsafe-nth args i)]
                  (if (not (starts-with? arg "-"))
                      (when (not (= i 0)) (push-back! cli-args @arg))
                      (match (parse-flag program arg (StaticArray.nth args (+ i 1)))
                        (Result.Success consumed) (+= i consumed)
                        (Result.Error err) (do (set! res (Result.Error err))
                                               (if fail (break) ()))))))
              res))))
)
